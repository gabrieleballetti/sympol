import numpy as np
import numba as nb


def _get_hilbert_basis_hom(
    generators, inequalities, stop_at_height=-1, disable_numba=False
):
    """Wrapper for the numba implementation of the Hilbert basis computation.

    The idea is to allow support to run the wrapped function with pure Python
    to avoid overflows in the numba implementation. Not yet implemented.
    """
    if not disable_numba:
        generators = np.array(generators, dtype=np.int64)
        inequalities = np.array(inequalities, dtype=np.int64)
        func = _get_hilbert_basis_hom_numba
    else:
        func = _get_hilbert_basis_hom_numba.py_func

    return func(
        generators=generators,
        inequalities=inequalities,
        stop_at_height=stop_at_height,
    )


@nb.njit(
    nb.int64[:, :](nb.int64[:, :], nb.int64[:, :], nb.int32),
    cache=True,
)
def _get_hilbert_basis_hom_numba(generators, inequalities, stop_at_height):
    """
    Compute the Hilbert basis of the cone generated by a homogenized set of generators.
    Elements at height 1 are assumed to be irreducible.
    """

    # define a custom dot product since np.dot is not supported for int types
    def _dot(a, b):
        result = a[0] * b[0]
        for i in range(1, len(a)):
            result += a[i] * b[i]
        return result

    # sort the generators by height
    generators = generators[np.argsort(generators[:, 0])]

    irreducibles = [generators[0]]  # lowest height is irreducible
    others = np.empty_like(generators)

    # populate while removing duplicates
    i = 0
    for g in generators[1:]:
        if g[0] == irreducibles[0][0] and not np.array_equal(g, irreducibles[-1]):
            irreducibles.append(g)
        elif i == 0 or not np.array_equal(g, others[i - 1]):
            others[i] = g
            i += 1
    others = others[:i]

    while others.size > 0:
        x = others[-1]
        others = others[:-1]
        is_reducible = False

        for y in irreducibles:
            _stopped = False
            for i in range(inequalities.shape[0]):
                if _dot(inequalities[i], x - y) < 0:
                    _stopped = True
                    break
            if not _stopped:
                is_reducible = True
                break

        if is_reducible:
            continue

        for y in others:
            _stopped = False
            for i in range(inequalities.shape[0]):
                if _dot(inequalities[i], x - y) < 0:
                    _stopped = True
                    break
            if not _stopped:  # pragma: no cover
                is_reducible = True  # pragma: no cover
                break  # pragma: no cover

        if is_reducible:
            continue  # pragma: no cover

        irreducibles.append(x)
        if stop_at_height >= 0 and x[0] >= stop_at_height:
            break

    irr_arr = np.empty(
        (len(irreducibles), generators.shape[1]),
        dtype=generators.dtype,
    )

    i = 0
    for irr in irreducibles:
        irr_arr[i] = irr
        i += 1

    return irr_arr


def _check_hilbert_basis_in_polytope(
    generators, irreducibles, cone_inequalities, other_inequalities, disable_numba=False
):
    """Wrapper for the numba implementation of the Hilbert basis computation.

    The idea is to allow support to run the wrapped function with pure Python
    to avoid overflows in the numba implementation. Not yet implemented.
    """
    if not disable_numba:
        generators = np.array(generators, dtype=np.int64)
        irreducibles = np.array(irreducibles, dtype=np.int64)
        cone_inequalities = np.array(cone_inequalities, dtype=np.int64)
        other_inequalities = np.array(other_inequalities, dtype=np.int64)
        func = _check_hilbert_basis_in_polytope_numba
    else:
        func = _check_hilbert_basis_in_polytope_numba.py_func

    return func(
        generators=generators,
        irreducibles=irreducibles,
        cone_inequalities=cone_inequalities,
        other_inequalities=other_inequalities,
    )


@nb.njit(
    nb.boolean(nb.int64[:, :], nb.int64[:, :], nb.int64[:, :], nb.int64[:, :]),
    cache=True,
)
def _check_hilbert_basis_in_polytope_numba(
    generators, irreducibles, cone_inequalities, other_inequalities
):
    """
    Check if the Hilbert basis of the semigroup generated by a set of generators is
    contained in the polytope defined by the inequalities.
    """

    # define a custom dot product since np.dot is not supported for int types
    def _dot(a, b):
        result = a[0] * b[0]
        for i in range(1, len(a)):
            result += a[i] * b[i]
        return result

    _irreducibles = [i for i in irreducibles]
    while generators.size > 0:
        x = generators[-1]
        generators = generators[:-1]
        is_reducible = False

        for y in _irreducibles:
            _stopped = False
            for i in range(cone_inequalities.shape[0]):
                if _dot(cone_inequalities[i], x - y) < 0:
                    _stopped = True
                    break
            if not _stopped:
                is_reducible = True
                break

        if is_reducible:
            continue

        for y in generators:
            _stopped = False
            for i in range(cone_inequalities.shape[0]):
                if _dot(cone_inequalities[i], x - y) < 0:
                    _stopped = True
                    break
            if not _stopped:
                is_reducible = True
                break

        if is_reducible:
            continue

        # x is irreducible
        for i in range(other_inequalities.shape[0]):
            if _dot(other_inequalities[i, 1:], x) < -other_inequalities[i, 0]:
                return False

        _irreducibles.append(x)

    return True
