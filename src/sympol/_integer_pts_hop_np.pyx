import copy
import itertools
import numpy as np
cimport numpy as cnp

cnp.import_array()

ctypedef cnp.int64_t DTYPE_t

cpdef tuple get_parallelotope_points_np(
        cnp.ndarray[DTYPE_t, ndim=1] snf,
        DTYPE_t det,
        cnp.ndarray[DTYPE_t, ndim=2] VDinv,
        int k,
        cnp.ndarray[DTYPE_t, ndim=2] R,
        cnp.ndarray[DTYPE_t, ndim=1] t,
        int height=-1,
        bint count_only=False,
    ):
    """
    Get all the integer points in the half-open parallelotope generated by
    the columns of R. This is a modification of the SageMath implementation
    at sage/src/sage/geometry/integral_points.pxi (GPLv2+).
    Description of the parameters:
    snf: the diagonal Smith normal form of the matrix R
    det: the determinant of R
    VDinv: the inverse of the matrix VD, where D is the diagonal matrix
        in the Smith normal form of R
    k: the index of the first non-one entry in the diagonal of the Smith normal form
    R: the matrix whose columns generate the parallelotope
    t: the translation vector of the parallelotope
    height: if given, only return points with the given "height" (= first coordinate)
    count_only: if true, count the points at each height instead of collecting them
    """
    cdef int i, j
    cdef int dim = VDinv.shape[0]
    cdef int ambient_dim = R.shape[0]
    cdef DTYPE_t s = 0
    cdef list gens = []
    cdef cnp.ndarray[DTYPE_t, ndim=1] gen = np.zeros(ambient_dim, dtype=np.int64)
    cdef cnp.ndarray[DTYPE_t, ndim=1] q_times_d = np.zeros(dim, dtype=np.int64)
    cdef cnp.ndarray[DTYPE_t, ndim=1] h = np.zeros(ambient_dim, dtype=np.int64)
    for base in itertools.product(*[range(i) for i in snf]):
        for i in range(dim):
            s = 0
            for j in range(k, dim):
                s += VDinv[i, j] * base[j]
            q_times_d[i] = s % det
        for i in range(ambient_dim):
            s = 0
            for j in range(dim):
                s += R[i, j] * q_times_d[j]
            gen[i] = s // det + t[i]
            if i == 0:
                if height >= 0 and gen[0] != height:
                    break
                h[gen[0]] += 1
                if count_only:
                    break                
        else:
            # only executed if the loop did not break
            gens.append(copy.copy(gen))
    return tuple(gens), h
